"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require("crypto");
const jsonwebtoken_1 = require("jsonwebtoken");
const querystring = require("querystring");
const request = require("superagent");
const url = require("url");
const constant_1 = require("./constant");
class ExchangeApi {
    constructor(accessKey, secretKey) {
        this.accessKey = accessKey;
        this.secretKey = secretKey;
    }
    getAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkKeys();
            const payload = { access_key: this.accessKey, nonce: (new Date).getTime() };
            const token = jsonwebtoken_1.sign(payload, this.secretKey);
            const uri = url.format({
                protocol: 'https',
                hostname: constant_1.constant.UPBIT_URL_V1,
                pathname: constant_1.constant.UPBIT_URL_ACCOUNTS
            });
            const res = yield request.get(uri)
                .set('Authorization', `Bearer ${token}`);
            return res.body;
        });
    }
    getOrdersChance(market) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkKeys();
            const query = querystring.stringify({ market });
            const payload = {
                access_key: this.accessKey,
                nonce: (new Date).getTime(),
                query
            };
            const token = jsonwebtoken_1.sign(payload, this.secretKey);
            const uri = url.format({
                protocol: 'https',
                hostname: constant_1.constant.UPBIT_URL_V1,
                pathname: constant_1.constant.UPBIT_URL_ORDERS_CHANCE
            });
            const res = yield request.get(uri)
                .set('Authorization', `Bearer ${token}`)
                .query({ market });
            return res.body;
        });
    }
    getOrder(uuid, identifier) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkKeys();
            const query = querystring.stringify({ uuid, identifier });
            const payload = {
                access_key: this.accessKey,
                nonce: (new Date).getTime(),
                query
            };
            const token = jsonwebtoken_1.sign(payload, this.secretKey);
            const uri = url.format({
                protocol: 'https',
                hostname: constant_1.constant.UPBIT_URL_V1,
                pathname: constant_1.constant.UPBIT_URL_ORDER
            });
            const res = yield request.get(uri)
                .set('Authorization', `Bearer ${token}`)
                .query({ uuid })
                .query({ identifier });
            return res.body;
        });
    }
    getOrders(market, state, page, orderBy) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkKeys();
            const query = querystring.stringify({ market, state, page, order_by: orderBy });
            const payload = {
                access_key: this.accessKey,
                nonce: (new Date).getTime(),
                query
            };
            const token = jsonwebtoken_1.sign(payload, this.secretKey);
            const uri = url.format({
                protocol: 'https',
                hostname: constant_1.constant.UPBIT_URL_V1,
                pathname: constant_1.constant.UPBIT_URL_ORDERS
            });
            const res = yield request.get(uri)
                .set('Authorization', `Bearer ${token}`)
                .query({ market })
                .query({ state })
                .query({ page })
                .query({ order_by: orderBy });
            return res.body;
        });
    }
    postOrders(market, side, volume, price, ordType) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkKeys();
            const randomBytes = yield crypto.randomBytes(64);
            const identifier = randomBytes.toString('hex');
            const body = { market, side, volume, price, ord_type: ordType, identifier };
            const payload = {
                access_key: this.accessKey,
                nonce: (new Date).getTime(),
                query: querystring.stringify(body)
            };
            const token = jsonwebtoken_1.sign(payload, this.secretKey);
            const uri = url.format({
                protocol: 'https',
                hostname: constant_1.constant.UPBIT_URL_V1,
                pathname: constant_1.constant.UPBIT_URL_ORDERS
            });
            const res = yield request.post(uri)
                .set('Authorization', `Bearer ${token}`)
                .set('Content-type', 'application/json')
                .send(body);
            return res.body;
        });
    }
    delOrder(uuid) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkKeys();
            const query = { uuid };
            const payload = {
                access_key: this.accessKey,
                nonce: (new Date).getTime(),
                query: querystring.stringify(query)
            };
            const token = jsonwebtoken_1.sign(payload, this.secretKey);
            const uri = url.format({
                protocol: 'https',
                hostname: constant_1.constant.UPBIT_URL_V1,
                pathname: constant_1.constant.UPBIT_URL_ORDER
            });
            const res = yield request.del(uri)
                .set('Authorization', `Bearer ${token}`)
                .set('Content-type', 'application/json')
                .query({ uuid });
            return res.body;
        });
    }
    checkKeys() {
        if (!this.secretKey || !this.secretKey)
            throw new Error('API keys are not set');
    }
}
exports.ExchangeApi = ExchangeApi;
//# sourceMappingURL=exchange.js.map